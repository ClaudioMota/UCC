// This file was generated by UCC. Manual changes are discouraged as they may be overwritten in future generations.
// See https://github.com/ClaudioMota/UCC for more in information.

#include "parsers/lexer.h"

static int func_identifier(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 95: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_semicolon(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 59: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_to(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 46: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 46: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 2:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 2: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_comma(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 44: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_blank(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 9: case 13: case 32: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 9: case 13: case 32: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_breakLine(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 10: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_comment(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 47: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 47: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 2:
    switch(input)
    {
      case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 123: case 124: case 125: case 126: case 127: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: case 239: case 240: case 241: case 242: case 243: case 244: case 245: case 246: case 247: case 248: case 249: case 250: case 251: case 252: case 253: case 254: case 255: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 2: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_helpers(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 72: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 101: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 2:
    switch(input)
    {
      case 108: *state = 3; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 3:
    switch(input)
    {
      case 112: *state = 4; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 4:
    switch(input)
    {
      case 101: *state = 5; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 5:
    switch(input)
    {
      case 114: *state = 6; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 6:
    switch(input)
    {
      case 115: *state = 7; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 7:
    switch(input)
    {
      case 58: *state = 8; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 8:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 8: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_tokens(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 84: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 111: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 2:
    switch(input)
    {
      case 107: *state = 3; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 3:
    switch(input)
    {
      case 101: *state = 4; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 4:
    switch(input)
    {
      case 110: *state = 5; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 5:
    switch(input)
    {
      case 115: *state = 6; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 6:
    switch(input)
    {
      case 58: *state = 7; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 7:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 7: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_productions(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 80: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 114: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 2:
    switch(input)
    {
      case 111: *state = 3; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 3:
    switch(input)
    {
      case 100: *state = 4; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 4:
    switch(input)
    {
      case 117: *state = 5; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 5:
    switch(input)
    {
      case 99: *state = 6; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 6:
    switch(input)
    {
      case 116: *state = 7; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 7:
    switch(input)
    {
      case 105: *state = 8; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 8:
    switch(input)
    {
      case 111: *state = 9; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 9:
    switch(input)
    {
      case 110: *state = 10; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 10:
    switch(input)
    {
      case 115: *state = 11; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 11:
    switch(input)
    {
      case 58: *state = 12; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 12:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 12: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_reducer(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 82: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 101: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 2:
    switch(input)
    {
      case 100: *state = 3; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 3:
    switch(input)
    {
      case 117: *state = 4; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 4:
    switch(input)
    {
      case 99: *state = 5; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 5:
    switch(input)
    {
      case 101: *state = 6; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 6:
    switch(input)
    {
      case 114: *state = 7; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 7:
    switch(input)
    {
      case 58: *state = 8; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 8:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 8: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_attrib(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 61: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_sum(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 43: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_sub(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 45: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_mult(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 42: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_or(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 124: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_reduce(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 60: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 45: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 2:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 2: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_question(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 63: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_o_parentheses(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 40: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_c_parentheses(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 41: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_o_brackets(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 91: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_c_brackets(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 93: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_charLiteral(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 39: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 123: case 124: case 125: case 126: case 127: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: case 239: case 240: case 241: case 242: case 243: case 244: case 245: case 246: case 247: case 248: case 249: case 250: case 251: case 252: case 253: case 254: case 255: *state = 1; break;
      case 39: *state = 3; break;
      case 92: *state = 2; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 2:
    switch(input)
    {
      case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58: case 59: case 60: case 61: case 62: case 63: case 64: case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72: case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80: case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88: case 89: case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109: case 110: case 111: case 112: case 113: case 114: case 115: case 116: case 117: case 118: case 119: case 120: case 121: case 122: case 123: case 124: case 125: case 126: case 127: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 146: case 147: case 148: case 149: case 150: case 151: case 152: case 153: case 154: case 155: case 156: case 157: case 158: case 159: case 160: case 161: case 162: case 163: case 164: case 165: case 166: case 167: case 168: case 169: case 170: case 171: case 172: case 173: case 174: case 175: case 176: case 177: case 178: case 179: case 180: case 181: case 182: case 183: case 184: case 185: case 186: case 187: case 188: case 189: case 190: case 191: case 192: case 193: case 194: case 195: case 196: case 197: case 198: case 199: case 200: case 201: case 202: case 203: case 204: case 205: case 206: case 207: case 208: case 209: case 210: case 211: case 212: case 213: case 214: case 215: case 216: case 217: case 218: case 219: case 220: case 221: case 222: case 223: case 224: case 225: case 226: case 227: case 228: case 229: case 230: case 231: case 232: case 233: case 234: case 235: case 236: case 237: case 238: case 239: case 240: case 241: case 242: case 243: case 244: case 245: case 246: case 247: case 248: case 249: case 250: case 251: case 252: case 253: case 254: case 255: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 3:
    switch(input)
    {
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 3: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int func_decimal(int* state, int input)
{
  switch(*state)
  {
    case 0:
    switch(input)
    {
      case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    case 1:
    switch(input)
    {
      case 48: case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: *state = 1; break;
      default: *state = LEXER_ERROR;
    }
    break;
    default: *state = LEXER_ERROR;
  }
  if(*state == LEXER_ERROR) return LEXER_ERROR;
  switch(*state)
  {
    case 1: return LEXER_ACCEPTED;
    default: return LEXER_PROCESSING;
  }
}

static int (*functions[])(int* state, int input) = {
  func_identifier,
  func_semicolon,
  func_to,
  func_comma,
  func_blank,
  func_breakLine,
  func_comment,
  func_helpers,
  func_tokens,
  func_productions,
  func_reducer,
  func_attrib,
  func_sum,
  func_sub,
  func_mult,
  func_or,
  func_reduce,
  func_question,
  func_o_parentheses,
  func_c_parentheses,
  func_o_brackets,
  func_c_brackets,
  func_charLiteral,
  func_decimal
};

int (**ucc_lexerFunctions)(int* state, int input) = functions;
int ucc_lexerFunctionCount = 24;

bool ucc_shouldIgnoreToken(Token* token)
{
  switch(token->type){
    case 4: case 5: case 6: return true;
    default: return false;
  }
}
