#include "generation/generation.h"
#include "basics.h"
#include "stdio.h"
#include "grammar/grammar.h"

static char* generationPath = "output/";
static char* baseOutputPath = "output/parsers/";
static char* linkToRepo = "https://github.com/ClaudioMota/UCC";

static void generateHeaderGuardsStart(FILE* file, char* headerTitle)
{
  fprintf(file, "#ifndef %s\n", headerTitle);
  fprintf(file, "#define %s 1\n", headerTitle);
  fprintf(file, "#ifdef __cplusplus\n");
  fprintf(file, "extern \"C\" {\n");
  fprintf(file, "#endif\n\n");
}

static void generateHeaderGuardsEnd(FILE* file)
{
  fprintf(file, "\n#ifdef __cplusplus\n");
  fprintf(file, "}\n");
  fprintf(file, "#endif\n");
  fprintf(file, "#endif\n");
}

static void generatedFileDisclaimer(FILE* file)
{
  fprintf(file, "// This file was generated by UCC. Manual changes are discouraged as they may be overwritten in future generations.\n");
  fprintf(file, "// See %s for more in information.\n\n", linkToRepo);
}

static bool generateParserHeader(char* basePath, char* fileName, Grammar* grammar, char* namespace)
{
  char fullPath[STRING_LENGTH*3];
  strcpy(fullPath, basePath);
  strcat(fullPath, fileName);

  FILE* file = fopen(fullPath, "wb");
  if(!file) return compilerError("could not open file for generation", nullptr);

  char headerTitle[STRING_LENGTH];
  strcpy(headerTitle, namespace);
  strcat(headerTitle, "_PARSER_HEADER");

  generatedFileDisclaimer(file);
  generateHeaderGuardsStart(file, headerTitle);
  
  fprintf(file, "enum %s_Tokens\n{\n  %s_T_UNKNOWN = -2,\n  %s_T_END_OF_INPUT = -1", namespace, namespace, namespace);
  for(int i = 0; i < grammar->tokenCount; i++)
    fprintf(file, ",\n  %s_T_%s", namespace, grammar->tokens[i].name);
  fprintf(file, "\n};\n\n");

  fprintf(file, "extern int (**%s_lexerFunctions)(int* state, int input);\n", namespace);
  fprintf(file, "extern int %s_lexerFunctionCount;\n\n", namespace);
  fprintf(file, "bool %s_shouldIgnoreToken(Token* token);\n", namespace);
  fprintf(file, "Parser %s_parse(Token* tokens, int productionStructSize);\n", namespace);

  generateHeaderGuardsEnd(file);

  fclose(file);

  return true;
}

static void generateTokenFunction(FILE* file, TokenExpr* token)
{
  fprintf(file, "static int func_%s(int* state, int input)\n{\n", token->name);
  fprintf(file, "  switch(*state)\n  {\n");
  for(int i = 0; i < token->stateMachine.stateCount; i++)
  {
    StateMachineState* state = token->stateMachine.states[i];
    fprintf(file, "    case %i:\n", state->index);
    fprintf(file,"    switch(input)\n    {\n      ");
    for(int j = 0; j < state->transitionCount; j++)
    {
      StateMachineTransition* transition = &state->transitions[j];
      for(int k = 0; k < SUPPORTED_CHARACTERS; k++)
        if(transition->values[k])
          fprintf(file,"case %i: ", k);
      fprintf(file,"*state = %i; break;\n      ", transition->target->index);
    }

    fprintf(file,"default: *state = LEXER_ERROR;\n    }\n    break;\n");
  }

  fprintf(file,"    default: *state = LEXER_ERROR;\n  }\n");
  fprintf(file, "  if(*state == LEXER_ERROR) return LEXER_ERROR;\n  switch(*state)\n  {\n    ");
  for(int i = 0; i < token->stateMachine.stateCount; i++)
    if(token->stateMachine.states[i]->accepted)
      fprintf(file,"case %i: ", i);

  fprintf(file,"return LEXER_ACCEPTED;\n    default: return LEXER_PROCESSING;\n  }\n}\n\n");
}

static void generateLexerSource(FILE* file, Grammar* grammar, char* namespace)
{
  for(int i = 0; i < grammar->tokenCount; i++) generateTokenFunction(file, &grammar->tokens[i]);

  fprintf(file, "static int (*functions[])(int* state, int input) = {");
  for(int i = 0; i < grammar->tokenCount; i++)
  {
    if(i) fprintf(file, ",");
    fprintf(file, "\n  func_%s", grammar->tokens[i].name);
  }

  fprintf(file, "\n};\n\nint (**%s_lexerFunctions)(int* state, int input) = functions;\n", namespace);
  fprintf(file, "int %s_lexerFunctionCount = %i;\n\n", namespace, grammar->tokenCount);
  fprintf(file, "bool %s_shouldIgnoreToken(Token* token)\n{\n  switch(token->type){\n    ", namespace);

  bool hasIgnored = false;
  for(int i = 0; i < grammar->tokenCount; i++)
    if(grammar->tokens[i].ignored)
    {
      hasIgnored = true;
      fprintf(file, "case %i: ", grammar->tokens[i].index);
    }
  if(hasIgnored) fprintf(file, "return true;\n    ");
  fprintf(file, "default: return false;\n  }\n");
  fprintf(file, "}\n\n");
}

static void generateSyntaxSource(FILE* file, Grammar* grammar, LalrMachine* lalrMachine, char* namespace)
{
  
}

static bool generateParserSource(char* basePath, char* fileName, Grammar* grammar, LalrMachine* lalrMachine, char* namespace)
{
  char fullPath[STRING_LENGTH*3];
  strcpy(fullPath, basePath);
  strcat(fullPath, fileName);

  FILE* file = fopen(fullPath, "wb");
  if(!file) return compilerError("could not open file for generation", nullptr);

  generatedFileDisclaimer(file);

  fprintf(file, "#include \"parsers/lexer.h\"\n");
  fprintf(file, "#include \"parsers/parser.h\"\n");
  
  generateLexerSource(file, grammar, namespace);
  generateSyntaxSource(file, grammar, lalrMachine, namespace);
  
  fclose(file);

  return true;
}

bool generateGrammar(Grammar* grammar, LalrMachine* lalrMachine, char* namespace)
{
  char finalBasePath[STRING_LENGTH*3];

  strcpy(finalBasePath, baseOutputPath);
  strcat(finalBasePath, namespace);
  strcat(finalBasePath, "/");

  createDirectory(generationPath);
  createDirectory(baseOutputPath);
  createDirectory(finalBasePath);

  if(!generateParserHeader(finalBasePath, "parser.h", grammar, namespace)) return false;
  if(!generateParserSource(finalBasePath, "parser.c", grammar, lalrMachine, namespace)) return false;

  return true;
}
