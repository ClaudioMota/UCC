#include "basics.h"
#include "stdio.h"
#include "grammar/grammar.h"

static char* generationPath = "generated/";
static char* baseOutputPath = "generated/parsers/";
static char* linkToRepo = "https://github.com/ClaudioMota/UCC";

static void generateHeaderGuardsStart(FILE* file, char* headerTitle)
{
  fprintf(file, "#ifndef %s\n", headerTitle);
  fprintf(file, "#define %s 1\n", headerTitle);
  fprintf(file, "#ifdef __cplusplus\n");
  fprintf(file, "extern \"C\" {\n");
  fprintf(file, "#endif\n\n");
}

static void generateHeaderGuardsEnd(FILE* file)
{
  fprintf(file, "\n#ifdef __cplusplus\n");
  fprintf(file, "}\n");
  fprintf(file, "#endif\n");
  fprintf(file, "#endif\n");
}

static void generatedFileDisclaimer(FILE* file)
{
  fprintf(file, "// This file was generated by UCC. Manual changes are discouraged as they may be overwritten in future generations.\n");
  fprintf(file, "// See %s for more in information.\n\n", linkToRepo);
}

static bool generateLexerFunctionsHeader(char* path, char* namespace)
{
  FILE* file = fopen(path, "wb");
  if(!file) return compilerError("could not open file for generation", nullptr);

  char headerTitle[STRING_LENGTH];
  strcpy(headerTitle, namespace);
  strcat(headerTitle, "_LEXER_FUNCTIONS_HEADER");

  generatedFileDisclaimer(file);
  generateHeaderGuardsStart(file, headerTitle);
  
  fprintf(file, "extern int (**%s_lexerFunctions)(int* state, int input);\n", namespace);
  fprintf(file, "extern int %s_lexerFunctionCount;\n\n", namespace);
  fprintf(file, "bool %s_shouldIgnoreToken(Token* token);\n", namespace);

  generateHeaderGuardsEnd(file);

  fclose(file);

  return true;
}

static void generateTokenFunction(FILE* file, TokenExpr* token)
{
  fprintf(file, "static int func_%s(int* state, int input)\n{\n", token->name);
  fprintf(file, "  switch(*state)\n  {\n");
  for(int i = 0; i < token->stateMachine.stateCount; i++)
  {
    StateMachineState* state = token->stateMachine.states[i];
    fprintf(file, "    case %i:\n", state->index);
    fprintf(file,"    switch(input)\n    {\n      ");
    for(int j = 0; j < state->transitionCount; j++)
    {
      StateMachineTransition* transition = &state->transitions[j];
      for(int k = 0; k < SUPPORTED_CHARACTERS; k++)
        if(transition->values[k])
          fprintf(file,"case %i: ", k);
      fprintf(file,"*state = %i; break;\n      ", transition->target->index);
    }

    fprintf(file,"default: *state = LEXER_ERROR;\n    }\n    break;\n");
  }

  fprintf(file,"    default: *state = LEXER_ERROR;\n  }\n");
  fprintf(file, "  if(*state == LEXER_ERROR) return LEXER_ERROR;\n  switch(*state)\n  {\n    ");
  for(int i = 0; i < token->stateMachine.stateCount; i++)
    if(token->stateMachine.states[i]->accepted)
      fprintf(file,"case %i: ", i);

  fprintf(file,"return LEXER_ACCEPTED;\n    default: return LEXER_PROCESSING;\n  }\n}\n\n");
}

static bool generateLexerFunctionsSource(char* path, Grammar* grammar, char* namespace)
{
  FILE* file = fopen(path, "wb");
  if(!file) return compilerError("could not open file for generation", nullptr);

  generatedFileDisclaimer(file);

  fprintf(file, "#include \"parsers/lexer.h\"\n\n");
  
  for(int i = 0; i < grammar->tokenCount; i++) generateTokenFunction(file, &grammar->tokens[i]);

  fprintf(file, "static int (*functions[])(int* state, int input) = {");
  for(int i = 0; i < grammar->tokenCount; i++)
  {
    if(i) fprintf(file, ",");
    fprintf(file, "\n  func_%s", grammar->tokens[i].name);
  }

  fprintf(file, "\n};\n\nint (**%s_lexerFunctions)(int* state, int input) = functions;\n", namespace);
  fprintf(file, "int %s_lexerFunctionCount = %i;\n\n", namespace, grammar->tokenCount);
  fprintf(file, "bool %s_shouldIgnoreToken(Token* token)\n{\n  switch(token->type){\n    ", namespace);

  bool hasIgnored = false;
  for(int i = 0; i < grammar->tokenCount; i++)
    if(grammar->tokens[i].ignored)
    {
      hasIgnored = true;
      fprintf(file, "case %i: ", grammar->tokens[i].index);
    }
  if(hasIgnored) fprintf(file, "return true;\n    ");
  fprintf(file, "default: return false;\n  }\n");
  fprintf(file, "}\n");
  
  fclose(file);

  return true;
}

bool generateLexer(Grammar* grammar, char* namespace)
{
  char finalBasePath[STRING_LENGTH*3];
  char lexerFunctionsHeaderPath[STRING_LENGTH*3];
  char lexerFunctionsSourcePath[STRING_LENGTH*3];

  strcpy(finalBasePath, baseOutputPath);
  strcat(finalBasePath, namespace);

  createDirectory(generationPath);
  createDirectory(baseOutputPath);
  createDirectory(finalBasePath);

  strcpy(lexerFunctionsHeaderPath, finalBasePath);
  strcat(lexerFunctionsHeaderPath, "/lexerFunctions.h");

  strcpy(lexerFunctionsSourcePath, finalBasePath);
  strcat(lexerFunctionsSourcePath, "/lexerFunctions.c");

  if(!generateLexerFunctionsHeader(lexerFunctionsHeaderPath, namespace)) return false;
  if(!generateLexerFunctionsSource(lexerFunctionsSourcePath, grammar, namespace)) return false;
  return true;
}